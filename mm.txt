# ===============================================================
# ARMA Model on HDFC Data with Z-Test, Residuals, and RMSE
# ===============================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

# -------------------------------
# Step 1: Load Data and Compute Returns
# -------------------------------
# Replace path with your file location
df = pd.read_csv("/content/500180.csv")

# Assuming 'Close' column exists
df['Month'] = pd.to_datetime(df['Month'], errors='coerce')
df = df.sort_values('Month')

df['Return'] = df['Close Price'].pct_change()  # daily/monthly return
df = df.dropna(subset=['Return'])
returns = df['Return'].values

plt.figure(figsize=(10,4))
plt.plot(df['Month'], df['Return'])
plt.title("HDFC Stock Returns")
plt.xlabel("Month")
plt.ylabel("Return")
plt.show()

# -------------------------------
# Step 2: Define ARMA Simulation and Forecast Functions
# -------------------------------
def generate_arma(phi, theta, n=200, c=0, sigma=1):
    """
    Generate ARMA(p,q) process.
    phi   : list of AR coefficients
    theta : list of MA coefficients
    n     : series length
    c     : constant term
    sigma : noise std dev
    """
    p = len(phi)
    q = len(theta)
    X = np.zeros(n)
    eps = np.random.normal(0, sigma, n)

    for t in range(max(p,q), n):
        ar_part = sum(phi[i] * X[t-i-1] for i in range(p))
        ma_part = sum(theta[j] * eps[t-j-1] for j in range(q))
        X[t] = c + ar_part + eps[t] + ma_part
    return X

def arma_forecast(X, phi, theta, steps=10):
    """
    Forecast future values given ARMA coefficients.
    """
    p = len(phi)
    q = len(theta)
    n = len(X)
    eps = np.zeros(n + steps)
    forecast = np.zeros(n + steps)
    forecast[:n] = X

    for t in range(n, n+steps):
        ar_part = sum(phi[i] * forecast[t-i-1] for i in range(p))
        ma_part = sum(theta[j] * eps[t-j-1] for j in range(q))
        forecast[t] = ar_part + ma_part
    return forecast[n:]

# -------------------------------
# Step 3: Fit ARMA (manual)
# -------------------------------
# Example: try ARMA(2,1) manually first
phi = [-0.3, 0.6]
theta = [0.5]

# Fit model: simulate series same length as returns for demonstration
X = generate_arma(phi, theta, n=len(returns))
forecast_vals = arma_forecast(returns, phi, theta, steps=20)

# -------------------------------
# Step 4: Residuals and RMSE
# -------------------------------
residuals = returns - X[:len(returns)]
rmse = np.sqrt(np.mean(residuals**2))
print(f"RMSE: {rmse:.6f}")

plt.figure(figsize=(10,4))
plt.plot(residuals, label="Residuals")
plt.title("Residuals of ARMA(2,1) Fit")
plt.legend()
plt.show()

# -------------------------------
# Step 5: Z-Test on Residuals
# -------------------------------
# Null hypothesis: residuals ~ N(0, œÉ¬≤)
z_scores = (residuals - np.mean(residuals)) / np.std(residuals)
z_stat, p_val = stats.normaltest(residuals)

print(f"Z-test Statistic: {z_stat:.4f}")
print(f"P-value: {p_val:.4f}")

if p_val > 0.05:
    print("‚úÖ Fail to reject H0: Residuals look normally distributed.")
else:
    print("‚ùå Reject H0: Residuals are not normal.")

# -------------------------------
# Step 6: Plot Actual vs Forecast
# -------------------------------
plt.figure(figsize=(10,4))
plt.plot(range(len(returns)), returns, label="Actual Returns")
plt.plot(range(len(returns), len(returns)+20), forecast_vals, "r--", label="Forecast (Next 20)")
plt.legend()
plt.title("HDFC ARMA(2,1) Forecast")
plt.show()




# ===============================================================
# ARIMA Model on HDFC Data with Z-Test, Residuals, and RMSE
# ===============================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

# -------------------------------
# Step 1: Load Data and Compute Returns
# -------------------------------
df = pd.read_csv("/content/500180.csv")

# Assuming 'Month' and 'Close Price' columns exist
df['Month'] = pd.to_datetime(df['Month'], errors='coerce')
df = df.sort_values('Month')

df['Return'] = df['Close Price'].pct_change()
df = df.dropna(subset=['Return'])
returns = df['Return'].values

plt.figure(figsize=(10,4))
plt.plot(df['Month'], df['Return'], color='blue')
plt.title("HDFC Stock Returns")
plt.xlabel("Month")
plt.ylabel("Return")
plt.show()

# -------------------------------
# Step 2: Define ARIMA Simulation and Forecast Functions
# -------------------------------
def generate_arima(phi, theta, d=1, n=200, c=0, sigma=1):
    """
    Generate ARIMA(p,d,q) process manually.
    phi   : list of AR coefficients
    theta : list of MA coefficients
    d     : differencing order
    n     : series length
    c     : constant term
    sigma : noise std dev
    """
    p = len(phi)
    q = len(theta)
    diff_series = np.zeros(n)
    eps = np.random.normal(0, sigma, n)

    # Generate ARMA part on differenced series
    for t in range(max(p, q), n):
        ar_part = sum(phi[i] * diff_series[t - i - 1] for i in range(p))
        ma_part = sum(theta[j] * eps[t - j - 1] for j in range(q))
        diff_series[t] = c + ar_part + eps[t] + ma_part

    # Integrate (cumulative sum) 'd' times to get ARIMA
    series = diff_series.copy()
    for _ in range(d):
        series = np.cumsum(series)
    return series

def arima_forecast(X, phi, theta, d=1, steps=10):
    """
    Forecast future values for ARIMA(p,d,q).
    """
    # Difference input series d times
    diff_X = X.copy()
    for _ in range(d):
        diff_X = np.diff(diff_X)

    p = len(phi)
    q = len(theta)
    n = len(diff_X)
    eps = np.zeros(n + steps)
    forecast_diff = np.zeros(n + steps)
    forecast_diff[:n] = diff_X

    for t in range(n, n + steps):
        ar_part = sum(phi[i] * forecast_diff[t - i - 1] for i in range(p))
        ma_part = sum(theta[j] * eps[t - j - 1] for j in range(q))
        forecast_diff[t] = ar_part + ma_part

    # Integrate back 'd' times
    forecast = forecast_diff[n:]
    for _ in range(d):
        forecast = np.cumsum(forecast) + X[-1]
    return forecast

# -------------------------------
# Step 3: Fit ARIMA(p,d,q) Manually
# -------------------------------
# Example 1: ARIMA(2,1,1)
# phi = [0.6, -0.3]
# theta = [0.4]
# d = 1

# Example 2: ARIMA(3,2,2)
phi = [0.6,-0.3]
theta = [0.4]
d = 1

# Generate simulated ARIMA series
X = generate_arima(phi, theta, d=d, n=len(returns))
forecast_vals = arima_forecast(returns, phi, theta, d=d, steps=20)

# -------------------------------
# Step 4: Residuals and RMSE
# -------------------------------
residuals = returns - X[:len(returns)]
rmse = np.sqrt(np.mean(residuals**2))
print(f"\nRMSE: {rmse:.6f}")

plt.figure(figsize=(10,4))
plt.plot(residuals, label="Residuals", color='orange')
plt.title(f"Residuals of ARIMA({len(phi)},{d},{len(theta)}) Fit")
plt.legend()
plt.show()

# -------------------------------
# Step 5: Z-Test on Residuals
# -------------------------------
z_stat, p_val = stats.normaltest(residuals)
print(f"Z-test Statistic: {z_stat:.4f}")
print(f"P-value: {p_val:.4f}")

if p_val > 0.05:
    print("‚úÖ Fail to reject H‚ÇÄ: Residuals appear normally distributed.")
else:
    print("‚ùå Reject H‚ÇÄ: Residuals are not normally distributed.")

# -------------------------------
# Step 6: Plot Actual vs Forecast
# -------------------------------
plt.figure(figsize=(10,4))
plt.plot(range(len(returns)), returns, label="Actual Returns", color='blue')
plt.plot(range(len(returns), len(returns) + len(forecast_vals)),
         forecast_vals, "r--", label=f"Forecast (Next {len(forecast_vals)})")
plt.legend()
plt.title(f"HDFC ARIMA({len(phi)},{d},{len(theta)}) Forecast")
plt.show()


# =============================================================
# üìà Modern Portfolio Theory ‚Äî Multiple Securities + CML
# =============================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import glob

# =============================================================
# 1Ô∏è‚É£ Load all stock CSVs dynamically
# =============================================================
file_paths = glob.glob("/content/*.csv")  # adjust your folder path
print(f"Loaded {len(file_paths)} stock files:")
for path in file_paths:
    print(" -", path.split("/")[-1])

# =============================================================
# 2Ô∏è‚É£ Compute daily returns (%)
# =============================================================
def calculate_returns(df):
    return ((df['Close Price'] - df['Open Price']) / df['Open Price']) * 100

returns = []
stock_names = []

for file in file_paths:
    df = pd.read_csv(file)
    stock_name = file.split("/")[-1].split(".")[0]
    stock_names.append(stock_name)
    returns.append(calculate_returns(df))
print(len(returns))
# Combine all returns into one DataFrame
returns_df = pd.concat(returns, axis=1)
returns_df.columns = stock_names
returns_df.dropna(inplace=True)

# =============================================================
# 3Ô∏è‚É£ Compute mean returns and covariance matrix
# =============================================================
mean_returns = returns_df.mean().values
cov_matrix = returns_df.cov().values
n = len(stock_names)
U = np.ones(n)

# =============================================================
# 4Ô∏è‚É£ Compute Minimum Variance Portfolio (MVP)
# =============================================================
inv_cov = np.linalg.inv(cov_matrix)
w_mvp = np.dot(inv_cov, U) / np.dot(U.T, np.dot(inv_cov, U))

mvp_return = np.dot(w_mvp, mean_returns)
mvp_risk = np.sqrt(np.dot(w_mvp.T, np.dot(cov_matrix, w_mvp)))

print("\n‚úÖ Minimum Variance Portfolio Results")
print("Stocks:", stock_names)
print("Weights (%):", np.round(w_mvp * 100, 2))
print("Expected Return:", round(mvp_return, 4))
print("Expected Risk (Std Dev):", round(mvp_risk, 4))

# =============================================================
# 5Ô∏è‚É£ Analytical Efficient Frontier (Hyperbola)
# =============================================================
A = np.dot(mean_returns.T, np.dot(inv_cov, U))
B = np.dot(mean_returns.T, np.dot(inv_cov, mean_returns))
C = np.dot(U.T, np.dot(inv_cov, U))
D = B * C - A**2

target_returns = np.linspace(min(mean_returns), max(mean_returns), 200)
target_risks = np.sqrt((C * (target_returns**2) - 2 * A * target_returns + B) / D)

# =============================================================
# 6Ô∏è‚É£ Tangency Portfolio (Maximum Sharpe Ratio)
# =============================================================
risk_free_rate = 0.05  # <-- change this to your desired risk-free rate (% per period)

excess_returns = mean_returns - risk_free_rate
w_tan = np.dot(inv_cov, excess_returns) / np.dot(U.T, np.dot(inv_cov, excess_returns))
w_tan = w_tan / np.sum(w_tan)  # normalize to sum to 1

tan_return = np.dot(w_tan, mean_returns)
tan_risk = np.sqrt(np.dot(w_tan.T, np.dot(cov_matrix, w_tan)))
sharpe_ratio = (tan_return - risk_free_rate) / tan_risk

print("\n‚úÖ Tangency Portfolio Results")
print("Weights (%):", np.round(w_tan * 100, 2))
print("Expected Return:", round(tan_return, 4))
print("Expected Risk (Std Dev):", round(tan_risk, 4))
print("Sharpe Ratio:", round(sharpe_ratio, 4))

# =============================================================
# 7Ô∏è‚É£ Random Portfolios (for visualization)
# =============================================================
#num_portfolios = 5000
#random_weights = np.random.dirichlet(np.ones(n), num_portfolios)
#random_returns = random_weights.dot(mean_returns)
#random_risks = np.sqrt(np.einsum('ij,jk,ik->i', random_weights, cov_matrix, random_weights))

# =============================================================
# 8Ô∏è‚É£ Capital Market Line (CML)
# =============================================================
cml_x = np.linspace(0, max(random_risks), 100)
cml_y = risk_free_rate + sharpe_ratio * cml_x

# =============================================================
# 9Ô∏è‚É£ Plot: Efficient Frontier + MVP + Tangency + CML
# =============================================================
plt.figure(figsize=(10, 6))
#plt.scatter(random_risks, random_returns, c='lightgray', s=10, label='Random Portfolios')
plt.plot(target_risks, target_returns, 'b-', linewidth=2, label='Efficient Frontier')
plt.scatter(mvp_risk, mvp_return, c='red', marker='*', s=200, label='Minimum Variance Portfolio')
plt.scatter(tan_risk, tan_return, c='green', marker='D', s=120, label='Tangency Portfolio')
plt.plot(cml_x, cml_y, 'orange', linestyle='--', linewidth=2, label='Capital Market Line (CML)')

plt.title("Efficient Frontier, MVP & Capital Market Line (CML)", fontsize=14)
plt.xlabel("Risk (Standard Deviation)")
plt.ylabel("Expected Return (%)")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

def needleman_wunsch(seq1, seq2, match=1, mismatch=-1, gap=-2):
    """
    Global alignment (Needleman-Wunsch)
    """
    n, m = len(seq1), len(seq2)
    T = [[0] * (n + 1) for _ in range(m + 1)]  # rows=seq2, cols=seq1

    # Initialize first row/column
    for i in range(m + 1):
        T[i][0] = i * gap
    for j in range(n + 1):
        T[0][j] = j * gap

    # Fill matrix
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            sigma = match if seq1[j-1] == seq2[i-1] else mismatch
            T[i][j] = max(
                T[i-1][j-1] + sigma,  # diagonal
                T[i-1][j] + gap,      # up
                T[i][j-1] + gap       # left
            )

    # Traceback
    aligned1, aligned2 = "", ""
    i, j = m, n
    path = [(i, j)]

    while i > 0 or j > 0:
        sigma = match if i > 0 and j > 0 and seq1[j-1] == seq2[i-1] else mismatch
        if i > 0 and j > 0 and T[i][j] == T[i-1][j-1] + (match if seq1[j-1] == seq2[i-1] else mismatch):
            aligned1, aligned2 = seq1[j-1] + aligned1, seq2[i-1] + aligned2
            i, j = i - 1, j - 1
        elif i > 0 and T[i][j] == T[i-1][j] + gap:
            aligned1, aligned2 = "-" + aligned1, seq2[i-1] + aligned2
            i -= 1
        else:
            aligned1, aligned2 = seq1[j-1] + aligned1, "-" + aligned2
            j -= 1
        path.append((i, j))

    path = np.array(path)
    return aligned1, aligned2, T, path

# Example usage
seq1, seq2 = "AGTCG", "ATCG"
a1, a2, T, path = needleman_wunsch(seq1, seq2)

# --- Print alignment ---
score = T[len(seq2)][len(seq1)]
print("\n" + "="*60)
print("  NEEDLEMAN-WUNSCH GLOBAL SEQUENCE ALIGNMENT")
print("="*60)
print(f"\nSequence 1: {seq1}\nSequence 2: {seq2}")
print(f"\nAligned Sequence 1: {a1}\nAligned Sequence 2: {a2}\nAlignment Score: {score}")

line = "".join("|" if a1[i]==a2[i] else " " if "-" in (a1[i],a2[i]) else "." for i in range(len(a1)))
print("\nAlignment:\n" + a1 + "\n" + line + "\n" + a2)

# --- Print DP Matrix in 2D Table Format ---
df = pd.DataFrame(T,
                  index=["-"] + list(seq2),
                  columns=["-"] + list(seq1))
print("\n" + "="*60)
print("  Needleman-Wunsch Dynamic Programming Matrix")
print("="*60)
print(df.to_string(index=True, justify='center'))
print("="*60)

# --- Visualization ---
plt.figure(figsize=(8, 6))
T_array = np.array(T)
plt.imshow(T_array, cmap='Blues', origin='upper')
plt.colorbar(label='Score')

# Add sequence labels
plt.xticks(np.arange(len(seq1)+1), ['-'] + list(seq1))
plt.yticks(np.arange(len(seq2)+1), ['-'] + list(seq2))

# Overlay traceback path
plt.plot(path[:,1], path[:,0], color='red', linewidth=2, marker='o')
plt.title("Needleman-Wunsch Alignment Matrix")
plt.xlabel("Sequence 1")
plt.ylabel("Sequence 2")

plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()